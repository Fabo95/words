{"version":3,"file":"elementOrderHelpers.js","sourceRoot":"","sources":["../../../src/rules/utils/elementOrderHelpers.ts"],"names":[],"mappings":";;;AAiBA;;;;GAIG;AACI,MAAM,sBAAsB,GAAG,CACpC,QAAmB,EACnB,UAAyC,EACzC,EAAE;IACF,MAAM,YAAY,GAAG,QAAQ,CAAC,MAAM,CAClC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CACzE,CAAC;IAEF,MAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,CACpC,CAAC,IAAI,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,CACrD,CAAC;IAEF,OAAO,CAAC,YAAY,EAAE,cAAc,CAAC,CAAC;AACxC,CAAC,CAAC;AAbW,QAAA,sBAAsB,0BAajC;AAEF;;;;;GAKG;AACI,MAAM,iBAAiB,GAAG,CAC/B,YAAuB,EACvB,cAAyB,EACzB,UAAyC,EACzC,EAAE;IACF,MAAM,YAAY,GAAG,CAAC,QAAiB,EAAE,QAAiB,EAAE,EAAE;QAC5D,MAAM,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC;QAC3D,MAAM,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC;QAC3D,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,OAAO,CAAC,CAAC,CAAC;SACX;QACD,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,OAAO,CAAC,CAAC;SACV;QACD,OAAO,CAAC,CAAC;IACX,CAAC,CAAC;IAEF,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAChC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAElC,OAAO,CAAC,GAAG,YAAY,EAAE,GAAG,cAAc,CAAC,CAAC;AAC9C,CAAC,CAAC;AArBW,QAAA,iBAAiB,qBAqB5B","sourcesContent":["import { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\nimport {\n  ObjectLiteralElement,\n  Property,\n  RestElement,\n  TSEnumMember,\n  TypeElement,\n} from '@typescript-eslint/types/dist/ast-spec';\n\nexport type Element =\n  | (TSESTree.JSXAttribute | TSESTree.JSXSpreadAttribute)\n  | TSEnumMember\n  | TypeElement\n  | ObjectLiteralElement\n  | Property\n  | RestElement;\n\n/**\n * @param elements all uncategorized and unsorted elements.\n * @param sourceCode the sourceCode object used to getText.\n * @returns 2 categorized element arrays.\n */\nexport const getCategorizedElements = (\n  elements: Element[],\n  sourceCode: Readonly<TSESLint.SourceCode>\n) => {\n  const restElements = elements.filter(\n    (element) => !['{', '$'].includes(sourceCode.getText(element).charAt(0))\n  );\n\n  const dollarElements = elements.filter(\n    (prop) => sourceCode.getText(prop).charAt(0) === '$'\n  );\n\n  return [restElements, dollarElements];\n};\n\n/**\n * @param restElements all Elements except dollarElements.\n * @param dollarElements\n * @param sourceCode the sourceCode object used to getText.\n * @returns the sorted element arrays.\n */\nexport const getSortedElements = (\n  restElements: Element[],\n  dollarElements: Element[],\n  sourceCode: Readonly<TSESLint.SourceCode>\n) => {\n  const sortCallback = (elementA: Element, elementB: Element) => {\n    const a = sourceCode.getText(elementA).toLocaleLowerCase();\n    const b = sourceCode.getText(elementB).toLocaleLowerCase();\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  };\n\n  restElements.sort(sortCallback);\n  dollarElements.sort(sortCallback);\n\n  return [...restElements, ...dollarElements];\n};\n"]}